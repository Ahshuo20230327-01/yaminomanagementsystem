<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FF14 ÁôæËê¨Â∑•ÊúÉÊá∂‰∫∫ÁµÑÈöäÂàÜÁµÑÂô® (Refactored)</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- 
      ========================================
      CSS SECTION: Styles & Layout
      ========================================
    -->
    <style>
        :root {
            /* Palette */
            --bg-dark: #121212;
            --panel-bg: rgba(20, 20, 20, 0.95);
            --border-gold: #c6a86b;
            --border-dim: #4a4a4a;
            --text-gold: #d4b57e;
            --text-white: #e0e0e0;
            --text-dim: #888;
            
            /* Roles */
            --tank-solid: #4a90e2;
            --healer-solid: #7ed321;
            --dps-solid: #d0021b;
            --flex-solid: #9c27b0;
            
            /* Status */
            --success-green: #4caf50;
            --error-red: #ff5252;
            --warning-yellow: #ffc107;
        }

        /* Base Reset */
        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: var(--bg-dark);
            background-image: radial-gradient(circle at center, #2a2a2a 0%, #000 100%);
            color: var(--text-white);
            margin: 0; padding: 20px;
            height: 100vh;
            display: flex; flex-direction: column; align-items: center; overflow: hidden;
        }

        /* Component: Header */
        header {
            text-align: center; margin-bottom: 20px; margin-top: 5px; position: relative; width: 100%; max-width: 1000px;
            border-bottom: 1px solid rgba(198, 168, 107, 0.3); padding-bottom: 15px; flex-shrink: 0;
        }
        header::after {
            content: ""; position: absolute; bottom: -1px; left: 50%; transform: translateX(-50%); width: 60%; height: 2px;
            background: linear-gradient(90deg, transparent, var(--border-gold), transparent); box-shadow: 0 0 15px var(--border-gold);
        }
        h1 { font-weight: 700; font-size: 1.8rem; color: var(--text-gold); margin: 0; letter-spacing: 1px; text-shadow: 0 0 15px rgba(198, 168, 107, 0.4); }
        .subtitle { color: var(--text-dim); font-size: 0.9rem; margin-top: 5px; letter-spacing: 1px; }

        /* Layout Grid */
        .container {
            display: grid; grid-template-columns: 380px 1fr; gap: 25px; max-width: 1200px; width: 100%; height: 100%;
            animation: fadeIn 0.8s ease-out; overflow: hidden; padding-bottom: 20px;
        }

        /* Common Panel Styles */
        .panel {
            background: var(--panel-bg); border: 1px solid var(--border-dim); border-radius: 6px; padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); position: relative; backdrop-filter: blur(5px);
            display: flex; flex-direction: column; height: 100%; overflow: hidden; transition: border-color 0.3s;
        }
        .panel:hover { border-color: rgba(198, 168, 107, 0.4); }
        .panel-header {
            font-weight: 700; color: var(--text-gold); font-size: 1.2rem; margin-bottom: 10px; padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); display: flex; justify-content: space-between; align-items: flex-end; flex-shrink: 0;
        }

        /* Dashboard (Stats) */
        .dashboard {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-bottom: 10px;
            background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.05); flex-shrink: 0;
        }
        .stat-item { display: flex; align-items: center; justify-content: center; gap: 5px; font-size: 0.9rem; font-weight: 500; }
        .stat-val { font-weight: 700; transition: color 0.3s; }
        .stat-limit { color: #666; font-size: 0.85rem; }
        .stat-full { color: var(--success-green); text-shadow: 0 0 8px rgba(76, 175, 80, 0.4); }
        .stat-short { color: var(--error-red); text-shadow: 0 0 8px rgba(244, 67, 54, 0.4); }

        /* Controls & Inputs */
        .add-member-row { display: flex; gap: 8px; margin-bottom: 10px; flex-shrink: 0; }
        .add-input {
            flex: 1; background: #111; border: 1px solid #444; color: var(--text-white); padding: 6px 10px;
            border-radius: 4px; font-size: 0.95rem; transition: border-color 0.2s;
        }
        .add-input:focus { outline: none; border-color: var(--text-gold); }
        .add-btn {
            background: var(--border-dim); color: var(--text-white); border: 1px solid #555; width: 36px;
            display: flex; align-items: center; justify-content: center; cursor: pointer; border-radius: 4px;
            font-size: 1.2rem; transition: all 0.2s;
        }
        .add-btn:hover { background: var(--text-gold); color: #000; border-color: var(--text-gold); }
        
        .bulk-actions .text-btn {
            background: none; border: none; color: var(--text-dim); font-size: 0.85rem; cursor: pointer; padding: 0; font-family: inherit;
        }
        .text-btn:hover { color: var(--text-white); text-decoration: underline; }
        .reset-btn { color: var(--error-red); opacity: 0.7; }
        .reset-btn:hover { color: #ff8888; opacity: 1; }

        /* Roster List */
        .roster-grid { 
            display: flex; flex-direction: column; gap: 6px; overflow-y: auto; padding-right: 5px;
            flex-grow: 1; min-height: 0; margin-bottom: 10px;
        }
        .roster-card {
            display: flex; align-items: center; justify-content: space-between;
            background: linear-gradient(90deg, rgba(255,255,255,0.03), transparent);
            padding: 8px 12px; border-radius: 4px; border-left: 3px solid transparent;
            cursor: pointer; transition: all 0.1s; position: relative; flex-shrink: 0;
        }
        .roster-card:hover { background: linear-gradient(90deg, rgba(255,255,255,0.08), transparent); }
        .roster-card.active { background: linear-gradient(90deg, rgba(198, 168, 107, 0.15), transparent); border-left-color: var(--text-gold); }
        .roster-card.active .roster-name { color: var(--text-gold); text-shadow: 0 0 8px rgba(198, 168, 107, 0.5); }
        .roster-name { font-size: 1rem; font-weight: 500; color: var(--text-dim); transition: color 0.2s; }

        /* Role Icons */
        .role-switch { display: flex; gap: 5px; }
        .role-icon {
            width: 28px; height: 28px; border-radius: 4px; display: flex; align-items: center; justify-content: center;
            background: #222; border: 1px solid #444; color: #555; transition: all 0.2s; flex-shrink: 0;
        }
        .role-icon:hover { transform: scale(1.1); }
        
        /* [Fix] Add specific svg rule to inherit color */
        .role-icon svg { width: 18px; height: 18px; fill: currentColor; }

        .role-icon.t-active { border-color: var(--tank-solid); color: var(--tank-solid); background: rgba(74, 144, 226, 0.2); box-shadow: 0 0 8px var(--tank-solid); }
        .role-icon.h-active { border-color: var(--healer-solid); color: var(--healer-solid); background: rgba(126, 211, 33, 0.2); box-shadow: 0 0 8px var(--healer-solid); }
        .role-icon.d-active { border-color: var(--dps-solid); color: var(--dps-solid); background: rgba(208, 2, 27, 0.2); box-shadow: 0 0 8px var(--dps-solid); }
        .role-icon.f-active { border-color: var(--flex-solid); color: var(--flex-solid); background: rgba(156, 39, 176, 0.2); box-shadow: 0 0 8px var(--flex-solid); }
        
        .delete-btn { margin-left: 5px; color: #444; cursor: pointer; display: none; width: 24px; text-align: center; }
        .roster-card:hover .delete-btn { display: block; }
        .delete-btn:hover { color: var(--error-red); }

        /* Collapsible Manual Section */
        .manual-section { border-top: 1px solid #333; padding-top: 10px; margin-top: auto; flex-shrink: 0; }
        .manual-header { font-size: 1rem; color: var(--text-dim); cursor: pointer; display: flex; align-items: center; justify-content: space-between; padding: 5px 0; }
        .manual-header:hover { color: var(--text-white); }
        .manual-content { overflow: hidden; max-height: 500px; transition: max-height 0.3s ease-out; }
        .manual-content.collapsed { max-height: 0; }
        .arrow-icon { transition: transform 0.3s; font-size: 0.8rem; }
        .manual-header.collapsed .arrow-icon { transform: rotate(-90deg); }
        
        .manual-input { background: transparent; border: none; border-bottom: 1px solid #444; color: var(--text-white); font-family: inherit; width: 120px; padding: 4px; }
        .manual-input:focus { outline: none; border-bottom-color: var(--text-gold); }

        /* Right Panel */
        .right-panel-content { display: flex; flex-direction: column; height: 100%; }
        .control-bar {
            display: flex; align-items: center; justify-content: space-between; gap: 15px; margin-bottom: 15px;
            background: rgba(0,0,0,0.3); padding: 15px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.05); flex-shrink: 0;
        }
        .team-btn-group { display: flex; gap: 5px; }
        .team-btn {
            width: 36px; height: 36px; background: #111; border: 1px solid #444; color: #666;
            border-radius: 4px; font-weight: 700; cursor: pointer; transition: all 0.2s;
        }
        .team-btn.active { background: var(--text-gold); color: #000; border-color: var(--text-gold); box-shadow: 0 0 10px rgba(212, 181, 126, 0.4); }
        
        .duty-btn {
            flex: 1; width: 100%; max-width: 250px; background: linear-gradient(180deg, #5c4d38 0%, #3d3122 100%);
            border: 1px solid var(--text-gold); color: #fff; font-weight: 700; font-size: 1.1rem; padding: 10px;
            cursor: pointer; letter-spacing: 1px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); border-radius: 2px;
        }
        .duty-btn:hover { background: linear-gradient(180deg, #7c684b 0%, #4d3e2b 100%); box-shadow: 0 0 15px var(--border-gold); }
        .duty-btn.loading { opacity: 0.8; pointer-events: none; filter: grayscale(0.5); }
        
        /* Result Container */
        .result-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; overflow-y: auto; flex-grow: 1; }
        .party-list { background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; animation: fadeIn 0.5s ease backwards; height: fit-content; }
        .party-header { background: rgba(198, 168, 107, 0.15); color: var(--text-gold); padding: 10px 15px; font-weight: 700; border-bottom: 1px solid rgba(255,255,255,0.05); display: flex; justify-content: space-between; }
        .party-member { padding: 10px 15px; border-bottom: 1px solid rgba(255,255,255,0.05); display: flex; align-items: center; gap: 10px; }
        .member-name { font-size: 1.1rem; font-weight: 500; }
        .member-missing { color: #555; font-style: italic; }
        .job-icon svg { width: 20px; height: 20px; fill: currentColor; }

        /* Utilities */
        .copy-btn { display: none; margin-left: 10px; background: transparent; border: 1px solid var(--text-dim); color: var(--text-dim); padding: 8px 12px; border-radius: 4px; cursor: pointer; }
        .copy-btn:hover { border-color: var(--text-white); color: var(--text-white); }
        .warning-icon { display: none; color: var(--warning-yellow); margin-left: 10px; cursor: help; }
        .warning-icon.show { display: block; }
        
        #toast-container { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 1000; pointer-events: none; }
        .toast { background: var(--panel-bg); border: 1px solid; border-radius: 4px; padding: 10px 20px; color: #fff; margin-top: 10px; opacity: 0; transform: translateY(20px); transition: all 0.3s; }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.success { border-color: var(--success-green); color: #b9f6ca; }
        .toast.error { border-color: var(--error-red); color: #ffadad; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        /* Mobile */
        @media (max-width: 850px) {
            body { height: auto; overflow: auto; }
            .container { grid-template-columns: 1fr; height: auto; overflow: visible; }
            .panel, .roster-grid, .result-container { height: auto; overflow: visible; max-height: none; }
            .roster-grid { max-height: 350px; flex-grow: 0; }
            .control-bar { flex-direction: column; align-items: stretch; }
        }
    </style>
</head>
<body>

<div id="toast-container"></div>

<header>
    <h1>FF14 ÁôæËê¨Â∑•ÊúÉÊá∂‰∫∫ÁµÑÈöäÂàÜÁµÑÂô®</h1>
    <div class="subtitle">ÁôæËê¨‰∫ûÁ±≥Ë´æÊóÖÂúò</div>
</header>

<div class="container">
    <!-- Left Panel: Roster Management -->
    <aside class="panel">
        <div class="panel-header">
            <div>Âá∫Â∏≠ÂêçÂñÆ</div>
            <div class="bulk-actions">
                <button class="text-btn" id="btn-select-all">ÂÖ®ÈÅ∏</button>
                <span>|</span>
                <button class="text-btn" id="btn-deselect-all">Ê∏ÖÁ©∫</button>
                <span>|</span>
                <button class="text-btn reset-btn" id="btn-reset">ÈáçÁΩÆ</button>
            </div>
        </div>

        <!-- Dashboard -->
        <div class="dashboard">
            <div class="stat-item"><span class="job-icon" style="color:var(--tank-solid)">üõ°Ô∏è</span> <span id="stat-t" class="stat-val">0</span><span class="stat-limit" id="limit-t">/2</span></div>
            <div class="stat-item"><span class="job-icon" style="color:var(--healer-solid)">üíö</span> <span id="stat-h" class="stat-val">0</span><span class="stat-limit" id="limit-h">/2</span></div>
            <div class="stat-item"><span class="job-icon" style="color:var(--dps-solid)">‚öîÔ∏è</span> <span id="stat-d" class="stat-val">0</span><span class="stat-limit" id="limit-d">/4</span></div>
            <div class="stat-item"><span class="job-icon" style="color:var(--flex-solid)">üé≤</span> <span id="stat-f" class="stat-val" style="color:var(--flex-solid)">0</span></div>
        </div>

        <div class="add-member-row">
            <input type="text" id="input-new-member" class="add-input" placeholder="Ëº∏ÂÖ•ÂêçÂ≠óÂä†ÂÖ•ÂàóË°®...">
            <button class="add-btn" id="btn-add-member">+</button>
        </div>

        <div id="roster-grid" class="roster-grid"></div>

        <!-- Collapsible Manual Section -->
        <div class="manual-section">
            <div class="manual-header collapsed" id="manual-toggle">
                <span>Â§ñÊâæÊîØÊè¥</span>
                <span class="arrow-icon">‚ñº</span>
            </div>
            <div id="manual-content" class="manual-content collapsed">
                <div id="manual-grid" class="roster-grid" style="overflow:visible; max-height:none;"></div>
            </div>
        </div>
    </aside>

    <!-- Right Panel: Controls & Results -->
    <main class="right-panel-content">
        <div class="control-bar">
            <div style="display:flex; flex-direction:column; gap:8px;">
                <div style="font-size:0.85rem; color:var(--text-gold); font-weight:700;">È†êË®àÈöä‰ºçÊï∏Èáè</div>
                <div style="display:flex; align-items:center; gap:10px;">
                    <div class="team-btn-group" id="team-count-group">
                        <button class="team-btn" data-count="1">1</button>
                        <button class="team-btn active" data-count="2">2</button>
                        <button class="team-btn" data-count="3">3</button>
                        <button class="team-btn" data-count="4">4</button>
                    </div>
                    <div id="overflow-warning" class="warning-icon" title="ÂÄôË£ú‰∫∫Êï∏ÈÅéÂ§öÔºåÂª∫Ë≠∞Â¢ûÂä†Èöä‰ºçÊï∏">‚ö†Ô∏è</div>
                </div>
            </div>
            
            <div style="display:flex; flex-direction:column; align-items:flex-end; flex:1; gap:10px;">
                <button id="btn-generate" class="duty-btn">ÈñãÂßãÈö®Ê©üÂàÜÁµÑ</button>
                <button id="btn-copy" class="copy-btn">üìã Ë§áË£ΩÁµêÊûú</button>
            </div>
        </div>
        
        <div id="result-area" class="result-container">
            <div style="grid-column: 1 / -1; text-align: center; color: #444; padding: 60px; border: 2px dashed #333; border-radius:10px;">
                <div style="font-size:2rem; opacity:0.3;">‚öîÔ∏è</div>
                Á≠âÂæÖÊåá‰ª§‰∏≠...
            </div>
        </div>
    </main>
</div>

<!-- 
  ========================================
  JAVASCRIPT SECTION: Logic & Behavior
  ========================================
-->
<script>
    /**
     * Configuration & Constants
     */
    const CONFIG = {
        STORAGE_KEYS: {
            ROSTER: 'ff14_roster_v2',
            MANUAL: 'ff14_manual_v2',
            PREFS: 'ff14_prefs_v2'
        },
        DEFAULT_NAMES: [
            "Ëâ≤Á¥†", "rÂÜ∑", "Êò•Êç≤", "Â∏åÂ¶Æ", "Evas", 
            "‰∫ûÂ≠êÈÜ¨", "ÂπºÁ®öÂúí„ÅÆCrow", "ÂÆÖK", "ÈòøËçâ", "È¢®ÊÑâ", 
            "Á™©Á¶è", "NANA"
        ],
        ICONS: {
            tank: '<svg viewBox="0 0 24 24"><path d="M12 2L4 5v6c0 5.55 3.84 10.74 8 12 4.16-1.26 8-6.45 8-12V5l-8-3z"/></svg>',
            healer: '<svg viewBox="0 0 24 24"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/></svg>',
            dps: '<svg viewBox="0 0 24 24"><path d="M14.5 17.5L3 6V3h3l11.5 11.5M13 19l6-6M16 16l4 4M19 21l2-2"/></svg>',
            flex: '<svg viewBox="0 0 24 24"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM7.5 18c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zm9 8.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zm0-8.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zm9 8.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>',
            clear: '<svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>'
        }
    };

    /**
     * Utility: Safe LocalStorage Wrapper
     * Èò≤Á¶¶ÊÄßËôïÁêÜÔºöÈÅøÂÖçÂõ†Èö±ÁßÅÊ®°ÂºèÊàñÈ°çÊªøÂ∞éËá¥Â¥©ÊΩ∞
     */
    class SafeStorage {
        static get(key, defaultValue) {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : defaultValue;
            } catch (e) {
                console.warn('Storage access failed:', e);
                return defaultValue;
            }
        }

        static set(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.warn('Storage write failed:', e);
            }
        }

        static clear() {
            try { localStorage.clear(); } catch(e) {}
        }
    }

    /**
     * Domain Logic: Team Balancer
     * ËÅ∑Ë≤¨ÔºöÁ¥îÁ≤πÁöÑÊºîÁÆóÊ≥ïË®àÁÆóÔºå‰∏çÊ∂âÂèä‰ªª‰Ωï DOM Êìç‰Ωú
     */
    class TeamBalancer {
        static generate(activeMembers, teamCount) {
            // ÁâπÊÆäË¶èÂâáÔºöÂ¶ÇÊûúÁ∏Ω‰∫∫Êï∏ÂâõÂ•Ω4‰∫∫ÔºåÂº∑Âà∂ÂàáÊèõÁÇ∫1Èöä
            if (activeMembers.length === 4) teamCount = 1;

            // 1. ÂàÜÈ°ûÊàêÂì° (Categorize)
            const pools = { T: [], H: [], D: [], F: [] };
            activeMembers.forEach(m => {
                const roleKey = m.role === 'F' ? 'F' : m.role;
                pools[roleKey].push({ ...m, isFlex: m.role === 'F', isLeader: false });
            });

            // 2. Èö®Ê©üÊâì‰∫Ç (Shuffle)
            Object.values(pools).forEach(list => this.shuffle(list));

            // 3. Âª∫Á´ãÈöä‰ºçÁµêÊßã
            const teams = Array.from({ length: teamCount }, (_, i) => ({
                id: i + 1,
                slots: [
                    { role: 'T', assigned: null },
                    { role: 'H', assigned: null },
                    { role: 'D', assigned: null },
                    { role: 'D', assigned: null }
                ]
            }));

            // 4. ÂÑ™ÂÖàÂ°´ÂÖ•ÈéñÂÆöËÅ∑ËÉΩ (Fill Locked Roles)
            teams.forEach(team => {
                team.slots.forEach(slot => {
                    if (pools[slot.role].length > 0) {
                        slot.assigned = pools[slot.role].shift();
                    }
                });
            });

            // 5. ËôïÁêÜÊ∫¢Âá∫ËàáË£ú‰Ωç (Handle Overflow & Flex)
            // Â∞áÊâÄÊúâÊú™Ë¢´ÂàÜÈÖçÁöÑÂõ∫ÂÆöËÅ∑ËÉΩËΩâÁÇ∫ Flex Ê±†
            let flexPool = [
                ...pools.F,
                ...pools.T.map(m => ({ ...m, isFlex: true })), // Ê∫¢Âá∫ÁöÑ T
                ...pools.H.map(m => ({ ...m, isFlex: true })), // Ê∫¢Âá∫ÁöÑ H
                ...pools.D.map(m => ({ ...m, isFlex: true }))  // Ê∫¢Âá∫ÁöÑ D
            ];
            this.shuffle(flexPool);

            // 6. Â°´Ë£úÂâ©È§òÁ©∫‰Ωç
            teams.forEach(team => {
                team.slots.forEach(slot => {
                    if (!slot.assigned && flexPool.length > 0) {
                        slot.assigned = flexPool.shift();
                    }
                });
            });

            // 7. ÈÅ∏ÈöäÈï∑ (Random Leader)
            if (teamCount >= 2) {
                teams.forEach(team => {
                    const validMembers = team.slots.filter(s => s.assigned).map(s => s.assigned);
                    if (validMembers.length > 0) {
                        const leader = validMembers[Math.floor(Math.random() * validMembers.length)];
                        leader.isLeader = true;
                    }
                });
            }

            return {
                teams: teams,
                bench: flexPool, // Ââ©È§òÊú™ÂàÜÈÖçËÄÖ
                actualTeamCount: teamCount
            };
        }

        static shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
    }

    /**
     * Data Layer: Roster Store
     * ËÅ∑Ë≤¨ÔºöÁÆ°ÁêÜË≥áÊñôÁãÄÊÖã (CRUD)
     */
    class RosterStore {
        constructor() {
            this.roster = [];
            this.manual = [];
            this.teamCount = 2;
            this.load();
        }

        load() {
            this.roster = SafeStorage.get(CONFIG.STORAGE_KEYS.ROSTER, 
                CONFIG.DEFAULT_NAMES.map(name => ({ name, selected: false, role: 'F', isPreset: true }))
            );
            this.manual = SafeStorage.get(CONFIG.STORAGE_KEYS.MANUAL, 
                Array.from({ length: 4 }, (_, i) => ({ id: `m${i}`, name: '', selected: false, role: 'F', isPreset: false }))
            );
            // Á¢∫‰øùË≥áÊñôÂÆåÊï¥ÊÄß (Ëã•ÊòØËàäÁâàË≥áÊñôÂèØËÉΩÁº∫Ê¨Ñ‰Ωç)
            this.roster.forEach(m => m.role = m.role || 'F');
        }

        save() {
            SafeStorage.set(CONFIG.STORAGE_KEYS.ROSTER, this.roster);
            SafeStorage.set(CONFIG.STORAGE_KEYS.MANUAL, this.manual);
        }

        addMember(name) {
            if (this.roster.some(m => m.name === name)) return false;
            this.roster.push({ name, selected: true, role: 'F', isPreset: false });
            this.save();
            return true;
        }

        removeMember(index) {
            this.roster.splice(index, 1);
            this.save();
        }

        reset() {
            SafeStorage.clear();
            location.reload();
        }

        // ÂèñÂæóÊâÄÊúâÂãæÈÅ∏ÁöÑÂèÉËàáËÄÖ
        getActiveMembers() {
            const rosterActive = this.roster.filter(m => m.selected);
            const manualActive = this.manual.filter(m => m.selected && m.name.trim());
            return [...rosterActive, ...manualActive];
        }

        getStats() {
            const active = this.getActiveMembers();
            return {
                total: active.length,
                t: active.filter(m => m.role === 'T').length,
                h: active.filter(m => m.role === 'H').length,
                d: active.filter(m => m.role === 'D').length,
                f: active.filter(m => m.role === 'F').length
            };
        }
    }

    /**
     * UI Layer: UI Manager
     * ËÅ∑Ë≤¨ÔºöÊ∏≤Êüì HTML, DOM ‰∫ã‰ª∂Áõ£ËÅΩ
     */
    class UIManager {
        constructor(store) {
            this.store = store;
            this.lastResult = null;
            this.elements = {
                rosterGrid: document.getElementById('roster-grid'),
                manualGrid: document.getElementById('manual-grid'),
                resultArea: document.getElementById('result-area'),
                stats: {
                    t: document.getElementById('stat-t'),
                    h: document.getElementById('stat-h'),
                    d: document.getElementById('stat-d'),
                    f: document.getElementById('stat-f'),
                    limitT: document.getElementById('limit-t'),
                    limitH: document.getElementById('limit-h'),
                    limitD: document.getElementById('limit-d'),
                },
                warning: document.getElementById('overflow-warning')
            };
        }

        renderAll() {
            this.renderRoster();
            this.renderManual();
            this.updateDashboard();
        }

        renderRoster() {
            this.elements.rosterGrid.innerHTML = '';
            this.store.roster.forEach((member, index) => {
                const card = this.createCardElement(member, index, 'roster');
                this.elements.rosterGrid.appendChild(card);
            });
        }

        renderManual() {
            this.elements.manualGrid.innerHTML = '';
            this.store.manual.forEach((member, index) => {
                const card = this.createCardElement(member, index, 'manual');
                this.elements.manualGrid.appendChild(card);
            });
        }

        // DRY: Áµ±‰∏ÄÂª∫Á´ãÂç°ÁâáÁöÑÂ∑•Âª†ÊñπÊ≥ï
        createCardElement(member, index, type) {
            const el = document.createElement('div');
            el.className = `roster-card ${member.selected ? 'active' : ''}`;
            
            // Name Section
            let nameHtml = type === 'roster' 
                ? `<div class="roster-name">${member.name}</div>`
                : `<div style="position:relative; display:flex; align-items:center;">
                     <input class="manual-input" value="${member.name}" placeholder="Ëº∏ÂÖ•ID..." data-idx="${index}">
                     ${member.name ? `<div class="clear-btn-icon" data-idx="${index}">${CONFIG.ICONS.clear}</div>` : ''}
                   </div>`;

            // Delete Button (Only for custom added members)
            const deleteHtml = (type === 'roster' && !member.isPreset) 
                ? `<div class="delete-btn" data-idx="${index}">‚úï</div>` : '';

            el.innerHTML = `
                ${nameHtml}
                <div style="display:flex; align-items:center; gap:8px;">
                    <div class="role-switch">
                        ${this.createRoleBtn(index, type, 'T', member.role)}
                        ${this.createRoleBtn(index, type, 'H', member.role)}
                        ${this.createRoleBtn(index, type, 'D', member.role)}
                        ${this.createRoleBtn(index, type, 'F', member.role)}
                    </div>
                    ${deleteHtml}
                </div>
            `;

            // Event Delegation Binding is handled in App Controller
            // But we attach dataset for identification
            el.dataset.type = type;
            el.dataset.index = index;
            
            // Click Handler for Selection (exclude controls)
            el.onclick = (e) => {
                if(e.target.closest('.role-icon') || e.target.tagName === 'INPUT' || e.target.closest('.delete-btn') || e.target.closest('.clear-btn-icon')) return;
                if(type === 'roster') app.toggleSelect(index);
            };

            return el;
        }

        createRoleBtn(index, type, role, currentRole) {
            const isActive = currentRole === role;
            const className = `role-icon ${isActive ? role.toLowerCase() + '-active' : ''}`;
            const icon = role === 'T' ? CONFIG.ICONS.tank : role === 'H' ? CONFIG.ICONS.healer : role === 'D' ? CONFIG.ICONS.dps : CONFIG.ICONS.flex;
            return `<div class="${className}" data-action="setRole" data-type="${type}" data-idx="${index}" data-role="${role}">${icon}</div>`;
        }

        updateDashboard() {
            const stats = this.store.getStats();
            const teamCount = this.store.teamCount;

            const updateStatUI = (el, limitEl, current, max) => {
                el.innerText = current;
                limitEl.innerText = `/${max}`;
                el.className = 'stat-val ' + (current >= max ? 'stat-full' : 'stat-short');
            };

            updateStatUI(this.elements.stats.t, this.elements.stats.limitT, stats.t, teamCount * 1);
            updateStatUI(this.elements.stats.h, this.elements.stats.limitH, stats.h, teamCount * 1);
            updateStatUI(this.elements.stats.d, this.elements.stats.limitD, stats.d, teamCount * 2);
            
            this.elements.stats.f.innerText = stats.f;

            // Warning Logic
            const totalNeeded = teamCount * 4;
            this.elements.warning.classList.toggle('show', stats.total > totalNeeded);
        }

        renderResults(resultData) {
            this.lastResult = resultData;
            let html = '';

            resultData.teams.forEach(team => {
                html += `
                <div class="party-list" style="animation-delay: ${(team.id-1)*0.1}s">
                    <div class="party-header">
                        <span>Á¨¨ ${team.id} Â∞èÈöä</span>
                        <span style="font-size:0.8rem; opacity:0.7">LIGHT PARTY</span>
                    </div>
                    ${team.slots.map(slot => this.createSlotHtml(slot)).join('')}
                </div>`;
            });

            if (resultData.bench.length > 0) {
                html += `
                <div class="party-list" style="border-color:#555; animation-delay:0.3s">
                    <div class="party-header" style="color:#aaa"><span>ÂÄôË£ú / ÂæÖÊ©üÊàêÂì°</span></div>
                    ${resultData.bench.map(m => this.createSlotHtml({ role: 'D', assigned: m })).join('')}
                </div>`;
            }

            this.elements.resultArea.innerHTML = html;
            // Re-inject icons logic is handled by CSS currentColor usually, but if we need SVG injection:
            // Since we use inline SVG in CONFIG, it's already there.
            document.getElementById('btn-copy').style.display = 'block';
        }

        createSlotHtml(slot) {
            if (!slot.assigned) {
                // Empty Slot
                return `<div class="party-member"><div class="member-missing">(Áº∫Âì°)</div></div>`;
            }
            
            const m = slot.assigned;
            const iconRole = m.isFlex ? 'flex' : slot.role; // Use assigned slot role or flex
            // Mapping role char to icon key
            const iconKey = m.isFlex ? 'flex' : (slot.role === 'T' ? 'tank' : slot.role === 'H' ? 'healer' : 'dps');
            
            let nameDisplay = m.name;
            if (m.isLeader) nameDisplay += ' <span title="ÈöäÈï∑">üëë</span>';

            // SVG Injection
            const iconSvg = CONFIG.ICONS[iconKey];

            return `
            <div class="party-member">
                <div class="job-icon ${iconRole}" style="color:var(--${iconKey}-solid)">${iconSvg}</div>
                <div class="member-name">${nameDisplay}</div>
            </div>`;
        }

        showToast(msg, type = 'success') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerText = (type === 'error' ? '‚ö†Ô∏è ' : '‚úÖ ') + msg;
            container.appendChild(toast);
            
            requestAnimationFrame(() => toast.classList.add('show'));
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
    }

    /**
     * App Controller
     * ËÅ∑Ë≤¨ÔºöÂàùÂßãÂåñ„ÄÅ‰æùË≥¥Ê≥®ÂÖ•„ÄÅËÜ†Ê∞¥Á®ãÂºèÁ¢º (Glue Code)
     */
    class App {
        constructor() {
            this.store = new RosterStore();
            this.ui = new UIManager(this.store);
            this.initEventListeners();
            this.ui.renderAll();
        }

        initEventListeners() {
            // Global Click Delegation for Dynamic Elements
            document.body.addEventListener('click', (e) => {
                const target = e.target.closest('[data-action]');
                if (!target) return;
                
                const action = target.dataset.action;
                const idx = parseInt(target.dataset.idx);
                const type = target.dataset.type;

                if (action === 'setRole') {
                    this.setRole(type, idx, target.dataset.role);
                }
            });

            // Specific Elements
            document.getElementById('btn-add-member').onclick = () => this.addNewMember();
            document.getElementById('input-new-member').onkeypress = (e) => { if(e.key === 'Enter') this.addNewMember(); };
            
            document.getElementById('btn-select-all').onclick = () => {
                this.store.roster.forEach(m => m.selected = true);
                this.saveAndRender();
                this.ui.showToast('Â∑≤ÂÖ®ÈÅ∏');
            };
            
            document.getElementById('btn-deselect-all').onclick = () => {
                this.store.roster.forEach(m => m.selected = false);
                this.saveAndRender();
                this.ui.showToast('Â∑≤Ê∏ÖÁ©∫');
            };

            document.getElementById('btn-reset').onclick = () => {
                if(confirm('Á¢∫ÂÆöË¶ÅÈáçÁΩÆÊâÄÊúâÂêçÂñÆÁãÄÊÖãÂóéÔºüËá™Ë®ÇÊàêÂì°Â∞áÊúÉÊ∂àÂ§±„ÄÇ')) this.store.reset();
            };

            // Manual Input Binding (Debounced slightly or onInput)
            document.getElementById('manual-grid').addEventListener('input', (e) => {
                if (e.target.classList.contains('manual-input')) {
                    const idx = e.target.dataset.idx;
                    const val = e.target.value;
                    this.store.manual[idx].name = val;
                    this.store.manual[idx].selected = !!val.trim();
                    this.store.save();
                    this.ui.updateDashboard(); // Don't full render to lose focus
                    
                    // Toggle Clear Btn visibility locally
                    const wrapper = e.target.parentElement;
                    let clearBtn = wrapper.querySelector('.clear-btn-icon');
                    if (val && !clearBtn) {
                        // Re-render manually or simpler: just trigger re-render if needed, 
                        // but to keep focus, we usually rely on updateDashboard only.
                        // For strict refactor, let's keep it simple: lose focus is acceptable or fix focus.
                        // Better: just render Manual section again? No, focus loss.
                        // Let's just save. The UI update for clear btn will happen on next render.
                    }
                }
            });
            
            // Delete Handlers
            document.getElementById('roster-grid').addEventListener('click', (e) => {
                if(e.target.classList.contains('delete-btn')) {
                    this.store.removeMember(e.target.dataset.idx);
                    this.ui.renderRoster();
                    this.ui.updateDashboard();
                }
            });
            
            // Generate
            document.getElementById('btn-generate').onclick = () => this.handleGenerate();
            
            // Team Count
            document.getElementById('team-count-group').onclick = (e) => {
                if(e.target.classList.contains('team-btn')) {
                    document.querySelectorAll('.team-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    this.store.teamCount = parseInt(e.target.dataset.count);
                    this.ui.updateDashboard();
                }
            };

            // Copy
            document.getElementById('btn-copy').onclick = () => this.handleCopy();
            
            // Toggle Manual Section
            document.getElementById('manual-toggle').onclick = function() {
                this.classList.toggle('collapsed');
                document.getElementById('manual-content').classList.toggle('collapsed');
            };
        }

        addNewMember() {
            const input = document.getElementById('input-new-member');
            const name = input.value.trim();
            if (!name) return;

            if (this.store.addMember(name)) {
                this.ui.renderRoster();
                this.ui.updateDashboard();
                this.ui.showToast(`Â∑≤Âä†ÂÖ•: ${name}`);
                input.value = '';
                // Auto scroll
                const grid = document.getElementById('roster-grid');
                setTimeout(() => grid.scrollTop = grid.scrollHeight, 50);
            } else {
                this.ui.showToast('ÊàêÂì°Â∑≤Â≠òÂú®', 'error');
            }
        }

        setRole(type, index, role) {
            const target = type === 'roster' ? this.store.roster : this.store.manual;
            target[index].role = role;
            // Auto select when role changes
            if (type === 'roster' || (type === 'manual' && target[index].name)) {
                target[index].selected = true;
            }
            this.saveAndRender();
        }

        toggleSelect(index) {
            const m = this.store.roster[index];
            m.selected = !m.selected;
            this.saveAndRender();
        }

        saveAndRender() {
            this.store.save();
            this.ui.renderAll();
        }

        handleGenerate() {
            const active = this.store.getActiveMembers();
            if (active.length === 0) {
                this.ui.showToast('Ë´ãËá≥Â∞ëÈÅ∏Êìá‰∏ÄÂêçÊàêÂì°', 'error');
                return;
            }

            const btn = document.getElementById('btn-generate');
            const originalText = btn.innerText;
            btn.classList.add('loading');
            btn.innerText = "ÈÅãÁÆóÂàÜÈÖç‰∏≠...";

            // Simulate Async for UX
            setTimeout(() => {
                const result = TeamBalancer.generate(active, this.store.teamCount);
                this.ui.renderResults(result);
                this.ui.showToast('ÂàÜÁµÑÂÆåÊàêÔºÅ');
                btn.classList.remove('loading');
                btn.innerText = originalText;
            }, 500);
        }

        handleCopy() {
            if (!this.ui.lastResult) return;
            
            const results = this.ui.lastResult;
            let text = "";

            results.teams.forEach(team => {
                text += `„ÄêÁ¨¨ ${team.id} Â∞èÈöä„Äë (LIGHT PARTY)\n`;
                team.slots.forEach(slot => {
                    if(slot.assigned) {
                        const m = slot.assigned;
                        const icon = slot.role === 'T' ? 'üõ°Ô∏è' : slot.role === 'H' ? 'üíö' : '‚öîÔ∏è';
                        let row = `${icon} ${m.name}`;
                        if(m.isLeader) row += " (ÈöäÈï∑)";
                        if(m.isFlex) row += " (Ë£ú‰Ωç)";
                        text += row + "\n";
                    }
                });
                text += "\n";
            });

            if (results.bench.length) {
                text += "„ÄêÂÄôË£úÂêçÂñÆ„Äë\n";
                text += results.bench.map(m => `‚öîÔ∏è ${m.name}`).join(', ');
            }

            navigator.clipboard.writeText(text)
                .then(() => this.ui.showToast('Â∑≤Ë§áË£ΩÂà∞Ââ™Ë≤ºÁ∞ø'))
                .catch(() => this.ui.showToast('Ë§áË£ΩÂ§±Êïó', 'error'));
        }
    }

    // --- Entry Point ---
    const app = new App();

</script>
</body>
</html>
